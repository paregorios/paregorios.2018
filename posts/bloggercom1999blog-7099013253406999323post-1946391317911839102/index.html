<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Sorting Unicode Strings Across Languages and Writing Systems in Python | paregorios.org</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://paregorios.org/posts/bloggercom1999blog-7099013253406999323post-1946391317911839102/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Tom Elliott">
<meta name="robots" content="noindex">
<meta property="og:site_name" content="paregorios.org">
<meta property="og:title" content="Sorting Unicode Strings Across Languages and Writing Systems in Python">
<meta property="og:url" content="https://paregorios.org/posts/bloggercom1999blog-7099013253406999323post-1946391317911839102/">
<meta property="og:description" content="Sometimes when you put together a particular list of character strings, a particular use case, a particular audience, and default behaviors, you don't get what you need. Consider an arbitrarily-ordere">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2015-07-09T14:53:00-05:00">
<meta property="article:tag" content="horothesia">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://paregorios.org/">

                <span id="blog-title">paregorios.org</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../about/">About</a>
                </li>
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>
                </li>
<li>
<a href="../../resources/">Resources</a>
                </li>
<li>
<a href="../../rss.xml">RSS feed</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<li>
    <a href="index.src.html" id="sourcelink">Source</a>
    </li>

                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Sorting Unicode Strings Across Languages and Writing Systems in Python</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    Tom Elliott
            </span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2015-07-09T14:53:00-05:00" itemprop="datePublished" title="2015-07-09 14:53">2015-07-09 14:53</time></a></p>
            
        <p class="sourceline"><a href="index.src.html" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Sometimes when you put together a particular list of character strings, a particular use case, a particular audience, and default behaviors, you don't get what you need. Consider an arbitrarily-ordered list of Unicode strings:<br><br></p>
<pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; titles = [  <br> ...   u'Alétheia - Revista de estudos sobre Antigüidade e Medievo',  <br> ...   u'Archaeology Times',  <br> ...   u'ákoue',  <br> ...   u'Journal of Ancient Fish',  <br> ...   u'Zeitschrift für Numismatik',  <br> ...   u'Antípoda',  <br> ...   u'Antipodes',  <br> ...   u'Alecto',  <br> ...   u'Ägyptische Residenzen und Tempel',  <br> ...   u'Ακάμας, Όμιλος Ανάδειξης Μνημείων Σαλαμίνος, Ενημερωτικό Δελτίο',  <br> ...   u'Античный мир и археология',  <br> ...   u'ACME',  <br> ...   u'Ávila',  <br> ...   u'Άβιλα',  <br> ...   u'Araştırma Sonuçları Toplantıları',  <br> ...   u'Archäologische Informationen',  <br> ...   u'Académie des Inscriptions et Belles-Lettres: Lettre d’information',  <br> ...   u'Àvila',  <br> ...   u'‘Atiqot',  <br> ...   u'Aleppo'  <br> ... ]  <br></code></pre>
<br>Sort the list:<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; for title in sorted(titles): print title  <br> ...   <br> ACME  <br> Académie des Inscriptions et Belles-Lettres: Lettre d’information  <br> Alecto  <br> Aleppo  <br> Alétheia - Revista de estudos sobre Antigüidade e Medievo  <br> Antipodes  <br> Antípoda  <br> Araştırma Sonuçları Toplantıları  <br> Archaeology Times  <br> Archäologische Informationen  <br> Journal of Ancient Fish  <br> Zeitschrift für Numismatik  <br> Àvila  <br> Ávila  <br> Ägyptische Residenzen und Tempel  <br> ákoue  <br> Άβιλα  <br> Ακάμας, Όμιλος Ανάδειξης Μνημείων Σαλαμίνος, Ενημερωτικό Δελτίο  <br> Античный мир и археология  <br> ‘Atiqot  <br></code></pre>
<br>You and your users may not be satisfied with this result. Perhaps you'd prefer to see a list sorted across languages and scripts in a way that considers Roman characters (i.e., A-Z, a-z) as equivalent for purposes of sorting regardless of whether they bear diacritics or not (e.g., A == Á == À). Perhaps you'd like to go even further and consider characters equivalent across writing systems on the basis of a Romanization scheme (e.g., Greek <span style="background-color: #f0f0f0; font-family: arial; font-size: 12px; line-height: 20px;">α</span> == Russian <span style="background-color: #f0f0f0; font-family: arial; font-size: 12px; line-height: 20px;">а </span>== Latin/English a).<br><br>One way is to write a function that gives us an alternative sort key for each string; that is, a derivative string that, when sorted against other such strings, gives the desired result.<br><br>If we're comfortable with some amount of naiveté in the results, we can get this done pretty quickly for some languages and scripts by taking advantage of existing packages in the Python open-source ecosystem.<br><h2>How to ignore diacritics</h2>The venerable <a href="https://en.wikipedia.org/wiki/ASCII">ASCII character encoding scheme</a> (see also <a href="https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)">the "Basic Latin" Unicode code block</a>) provides for only the baseline Roman characters, plus Arabic numerals, English-standard punctuation, and some ancillary things that don't concern us here.<br><br><a href="https://pypi.python.org/pypi/Unidecode">Tomaz Solc's <i>unidecode</i> package</a> (a port of Sean M. Burke's <a href="http://search.cpan.org/~sburke/Text-Unidecode-1.23/lib/Text/Unidecode.pm"><i>Text::Unidecode</i> Perl module</a>) provides a quick and easy way to:<br><blockquote class="tr_bq"><span style="background-color: white; font-family: Arial, Verdana, Geneva, 'Bitstream Vera Sans', Helvetica, sans-serif; font-size: 14.640419960022px; line-height: 21.9606304168701px;">[take] Unicode data and [try] to represent it in ASCII characters ... where the compromises taken when mapping between two character sets are chosen to be near what a human with a US keyboard would choose.</span></blockquote>How does that work out for our example list of strings?<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; from unidecode import unidecode  <br> &gt;&gt;&gt; print(titles[0])  <br> Alétheia - Revista de estudos sobre Antigüidade e Medievo  <br> &gt;&gt;&gt; print(unidecode(titles[0]))  <br> Aletheia - Revista de estudos sobre Antiguidade e Medievo  <br> &gt;&gt;&gt; for title in titles: print(unidecode(title))  <br> ...   <br> Aletheia - Revista de estudos sobre Antiguidade e Medievo  <br> Archaeology Times  <br> akoue  <br> Journal of Ancient Fish  <br> Zeitschrift fur Numismatik  <br> Antipoda  <br> Antipodes  <br> Alecto  <br> Agyptische Residenzen und Tempel  <br> Akamas, Omilos Anadeixes Mnemeion Salaminos, Enemerotiko Deltio  <br> Antichnyi mir i arkheologiia  <br> ACME  <br> Avila  <br> Abila  <br> Arastirma Sonuclari Toplantilari  <br> Archaologische Informationen  <br> Academie des Inscriptions et Belles-Lettres: Lettre d'information  <br> Avila  <br> 'Atiqot  <br> Aleppo  <br></code></pre>
<br>You'll have noted that unidecode.unidecode() does more than just ignore diacritics. It attempts to transliterate non-Roman characters (i.e., "Romanize" them) as well. Indeed, note what the docs say:<br><blockquote class="tr_bq"><div style="background-color: white; font-family: Arial, Verdana, Geneva, 'Bitstream Vera Sans', Helvetica, sans-serif; font-size: 14.640419960022px; line-height: 1.5;">The quality of resulting ASCII representation varies. For languages of western origin it should be between perfect and good. On the other hand transliteration (i.e., conveying, in Roman letters, the pronunciation expressed by the text in some other writing system) of languages like Chinese, Japanese or Korean is a very complex issue and this library does not even attempt to address it. It draws the line at context-free character-by-character mapping. So a good rule of thumb is that the further the script you are transliterating is from Latin alphabet, the worse the transliteration will be.</div></blockquote>
<blockquote class="tr_bq"><div style="background-color: white; font-family: Arial, Verdana, Geneva, 'Bitstream Vera Sans', Helvetica, sans-serif; font-size: 14.640419960022px; line-height: 1.5;"><span style="font-size: 14.640419960022px; line-height: 1.5;">Note that this module generally produces better results than simply stripping accents from characters (which can be done in Python with built-in functions). It is based on hand-tuned character mappings that for example also contain ASCII approximations for symbols and non-Latin alphabets.</span></div></blockquote>
<h2>Alternative Romanization techniques</h2>I have no doubt that there are a wide variety of good techniques and packages for Romanizing character strings available in Python. I have not done a comprehensive search for these, and would welcome relevant, collegial comments with links on this post.<br><br>I did notice <a href="https://pypi.python.org/pypi/transliterate">Artur Barseghyan's <i>transliterate</i> package</a>. It is a:<br><blockquote class="tr_bq">
<span style="background-color: white; font-family: Arial, Verdana, Geneva, 'Bitstream Vera Sans', Helvetica, sans-serif; font-size: 14.640419960022px; line-height: 17.8231201171875px;">Bi-directional transliterator for Python [that] transliterates (unicode) strings</span><br><span style="background-color: white; font-family: Arial, Verdana, Geneva, 'Bitstream Vera Sans', Helvetica, sans-serif; font-size: 14.640419960022px; line-height: 17.8231201171875px;">according to the rules specified in the language packs (source script &lt;-&gt;</span><br><span style="background-color: white; font-family: Arial, Verdana, Geneva, 'Bitstream Vera Sans', Helvetica, sans-serif; font-size: 14.640419960022px; line-height: 17.8231201171875px;">target script).</span>
</blockquote>At the time of this writing, the package provided Romanization for strings identifiable as written in the standard scripts (as cataloged in the IANA language subtag registry) for the following languages:<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; from transliterate import get_available_language_codes as get_langs  <br> &gt;&gt;&gt; get_langs()  <br> ['el', 'ka', 'hy', 'ru', 'bg', 'uk']  </code></pre>
<h3>Side note: getting language names for IANA codes</h3>There's open source for that too: <a href="https://github.com/mattcg/language-subtag-registry">Matthew Caruana Galizia's IANA Language Tags project</a>, about which:<br><blockquote class="tr_bq">
<span style="background-color: white; color: #333333; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px;">IANA's </span><a href="http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry" style="background-color: white; box-sizing: border-box; color: #4078c0; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px; text-decoration: none;">official repository</a><span style="background-color: white; color: #333333; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px;"> is in </span><a href="http://www.inter-locale.com/ID/draft-phillips-record-jar-01.html" style="background-color: white; box-sizing: border-box; color: #4078c0; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px; text-decoration: none;">record-jar</a><span style="background-color: white; color: #333333; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px;"> format and is hard to parse. This project provides neatly organized JSON files representing that data.</span>
</blockquote>It also provides a JavaScript API. But I don't need that for this purpose. I can just grab the JSON version of the IANA repository data from Python, with an assist from <a href="http://docs.python-requests.org/en/latest/">the <i>requests</i> package</a>. I can then use it to make human-readable names for the languages the <i>transliterate</i> package supports:<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; import requests  <br> &gt;&gt;&gt; r = requests.get('https://raw.githubusercontent.com/mattcg/language-subtag-registry/master/data/json/registry.json')  <br> &gt;&gt;&gt; r.status_code  <br> 200  <br> &gt;&gt;&gt; lang_registry = r.json()  <br> &gt;&gt;&gt; languages = {}  <br> &gt;&gt;&gt; for lang in lang_registry:  <br> ...   if lang['Type'] == 'language':  <br> ...     languages[lang['Subtag']] = lang['Description'][0]  <br> ...   <br> &gt;&gt;&gt; len(languages)  <br> 8094  <br> &gt;&gt;&gt; romanizable_languages = [languages[code] for code in get_langs()]  <br> &gt;&gt;&gt; for l in romanizable_languages: print(l)  <br> ...   <br> Modern Greek (1453-)  <br> Georgian  <br> Armenian  <br> Russian  <br> Bulgarian  <br> Ukrainian  <br></code></pre>
<br>Of course, there's a lot more one can do with that IANA JSON file... but let's get back to Romanization, by way of ...<br><h3>Language and script detection</h3>The <i>transliterate</i> package demands that you be able to identify the language (and implicitly the writing system) of the string you want to Romanize. The package provides a "very basic" language detection method to help us out:<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; from transliterate import detect_language  <br> &gt;&gt;&gt; for title in titles: print(u'{0}: "{1}"'.format(detect_language(title), title))  <br> ...   <br> ru: "Alétheia - Revista de estudos sobre Antigüidade e Medievo"  <br> ru: "Archaeology Times"  <br> None: "ákoue"  <br> ru: "Journal of Ancient Fish"  <br> ru: "Zeitschrift für Numismatik"  <br> ru: "Antípoda"  <br> ru: "Antipodes"  <br> ru: "Alecto"  <br> ru: "Ägyptische Residenzen und Tempel"  <br> el: "Ακάμας, Όμιλος Ανάδειξης Μνημείων Σαλαμίνος, Ενημερωτικό Δελτίο"  <br> ru: "Античный мир и археология"  <br> ru: "ACME"  <br> None: "Ávila"  <br> el: "Άβιλα"  <br> ru: "Araştırma Sonuçları Toplantıları"  <br> ru: "Archäologische Informationen"  <br> ru: "Académie des Inscriptions et Belles-Lettres: Lettre d’information"  <br> None: "Àvila"  <br> ru: "‘Atiqot"  <br> ru: "Aleppo"  <br></code></pre>
<br>The apparent default value for any pure-ASCII string of 'ru' (Russian) problematic.<br><br>There is another package designed specifically for language detection: <a href="https://pypi.python.org/pypi/langid">Marco Lui's <i>langid</i> package</a>:<br><blockquote class="tr_bq">
<div style="box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px; margin-bottom: 16px;">
<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 13.6000003814697px; margin: 0px; padding: 0.2em 0px;">langid.py</code> is a standalone Language Identification (LangID) tool.</div>
<div style="box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px; margin-bottom: 16px;">The design principles are as follows:</div>
<ol style="box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 23.2727279663086px; margin-bottom: 16px; margin-top: 0px; padding: 0px 0px 0px 2em;">
<li style="box-sizing: border-box;">Fast</li>
<li style="box-sizing: border-box;">Pre-trained over a large number of languages (currently 97)</li>
<li style="box-sizing: border-box;">Not sensitive to domain-specific features (e.g. HTML/XML markup)</li>
<li style="box-sizing: border-box;">Single .py file with minimal dependencies</li>
<li style="box-sizing: border-box;">Deployable as a web service</li>
</ol>
</blockquote>Let's give it a whirl:<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; import langid  <br> &gt;&gt;&gt; print(titles[0])  <br> Alétheia - Revista de estudos sobre Antigüidade e Medievo  <br> &gt;&gt;&gt; langid.classify(titles[0])  <br> ('pt', 0.9997639656878511)  <br> &gt;&gt;&gt; for title in titles: print(u'{0}: "{1}"'.format(repr(langid.classify(title)), title))  <br> ...   <br> ('pt', 0.9997639656878511): "Alétheia - Revista de estudos sobre Antigüidade e Medievo"  <br> ('hu', 0.4951981167657506): "Archaeology Times"  <br> ('cs', 0.6559598835005537): "ákoue"  <br> ('en', 0.9999542989722191): "Journal of Ancient Fish"  <br> ('de', 1.0): "Zeitschrift für Numismatik"  <br> ('cs', 0.9327142178388013): "Antípoda"  <br> ('pt', 0.35121448605116784): "Antipodes"  <br> ('en', 0.16946150595865334): "Alecto"  <br> ('de', 0.9999999632942209): "Ägyptische Residenzen und Tempel"  <br> ('el', 1.0): "Ακάμας, Όμιλος Ανάδειξης Μνημείων Σαλαμίνος, Ενημερωτικό Δελτίο"  <br> ('ru', 0.9999999999665641): "Античный мир и археология"  <br> ('en', 0.16946150595865334): "ACME"  <br> ('lv', 0.3049662840719183): "Ávila"  <br> ('el', 1.0): "Άβιλα"  <br> ('tr', 0.9999345038597317): "Araştırma Sonuçları Toplantıları"  <br> ('de', 0.9999982379021314): "Archäologische Informationen"  <br> ('fr', 0.9999999999999973): "Académie des Inscriptions et Belles-Lettres: Lettre d’information"  <br> ('en', 0.16946150595865334): "Àvila"  <br> ('fr', 0.9511801373660571): "‘Atiqot"  <br> ('en', 0.31773663282480374): "Aleppo"  <br> &gt;&gt;&gt; for title in titles: print(u'{0}: "{1}"'.format([None, languages[langid.classify(title)[0]]][langid.classify(title)[1] &gt; 0.9], title))  <br> ...   <br> Portuguese: "Alétheia - Revista de estudos sobre Antigüidade e Medievo"  <br> None: "Archaeology Times"  <br> None: "ákoue"  <br> English: "Journal of Ancient Fish"  <br> German: "Zeitschrift für Numismatik"  <br> Czech: "Antípoda"  <br> None: "Antipodes"  <br> None: "Alecto"  <br> German: "Ägyptische Residenzen und Tempel"  <br> Modern Greek (1453-): "Ακάμας, Όμιλος Ανάδειξης Μνημείων Σαλαμίνος, Ενημερωτικό Δελτίο"  <br> Russian: "Античный мир и археология"  <br> None: "ACME"  <br> None: "Ávila"  <br> Modern Greek (1453-): "Άβιλα"  <br> Turkish: "Araştırma Sonuçları Toplantıları"  <br> German: "Archäologische Informationen"  <br> French: "Académie des Inscriptions et Belles-Lettres: Lettre d’information"  <br> None: "Àvila"  <br> French: "‘Atiqot"  <br> None: "Aleppo"  <br></code></pre>
<br>That's better, especially if we pay attention to the probability measures attached to each result.<br><h2>The missing pieces</h2>So, I think we can now imagine some process that follows this outline:<br><br><ul>
<li>for each string:</li>
<ul>
<li>if not every character in the string is ASCII</li>
<ul>
<li>try to use langid.classify() to determine language</li>
<ul>
<li>if language is successfully determined:</li>
<ul><li>if transliterate.translit() supports the language, get the transliteration</li></ul>
</ul>
<li>remove remaining non-ASCII characters by brute force</li>
<li>if result is a zero-length string, step back to the original string (what else can you do?)</li>
</ul>
<li>else: just use the original string</li>
<li>strip all the punctuation</li>
<li>convert everything to lowercase</li>
<li>normalize or remove spaces (depending on how you want to deal with word breaks in sorting)</li>
</ul>
</ul>
<h3>ASCII detection and stripping</h3>It's pretty easy to strip non-ASCII characters from a Unicode string in Python: <br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; t = u"Antípoda"  <br> &gt;&gt;&gt; t.encode('ascii', 'ignore')  <br> 'Antpoda'  <br></code></pre>
<br>We can exploit this to do quick and dirty "all ASCII" detection:<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; t = u"Antípoda"  <br> &gt;&gt;&gt; t == unicode(u.encode('ascii', 'ignore'))  <br> False  <br> &gt;&gt;&gt; u = u'Chicken'  <br> &gt;&gt;&gt; u == unicode(u.encode('ascii', 'ignore'))  <br> True  <br></code></pre>
<br>This approach depends upon the assumption that the strings you're starting with are really Unicode strings. If you were a huge regular expressions fan, you could use the python re module to perform a similar test, but I'm betting it would run slower.<br><br>If you weren't so confident in the consistency of your source list, you'd need to do some preprocessing. Unicode normalization might be necessary. You might have to resort to the chardet module in order to guess at encodings.<br><h3>Stripping punctuation</h3>Now here's a job for regular expressions. We can make short work of this task especially if we take advantage of <a href="https://pypi.python.org/pypi/regex">the new, alternative <i>regex</i> package for Python</a>, which is intended to eventually replace the current implementation.<br><br><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &gt;&gt;&gt; import regex as re  <br> &gt;&gt;&gt; rx = re.compile(ur'[\p{P}_\d]+')  <br> &gt;&gt;&gt; t = u'Ακάμας, Όμιλος Ανάδειξης Μνημείων Σαλαμίνος, Ενημερωτικό Δελτίο'  <br> &gt;&gt;&gt; print(rx.sub(u'', t))  <br> Ακάμας Όμιλος Ανάδειξης Μνημείων Σαλαμίνος Ενημερωτικό Δελτίο  </code></pre>
<h2>Putting it all together</h2>Consider the following script:<br><br>
</div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/horothesia/" rel="tag">horothesia</a></li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2018         <a href="mailto:ipse@paregorios.org">Tom Elliott</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
